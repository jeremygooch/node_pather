#!/usr/bin/env nodejs

global.prax = global.prax || {};

prax.getSettings = function() {
    /* 
     * This function is used to define the basic settings including the 
     * input values
     *
     * @RETURN = An object containing the settings for the pather application
     */
    var args = [];
    process.argv.forEach(function (val, index) {
	args[index] = val;
    });

    return {
	'symbols' : {
	    'mark'	: '#',
	    'off'	: '.',
	    'on'	: '*',
	},
	'input'		: args[2],
	'output'	: args[3],
	'fs'		: require('fs'),
	'totalMarks'    : 0
    };
};

prax.writeOutput = function(fs, outputArr, outputFile) {
    // Convert the output array into a string that can be written to a file
    var outputStr = '';
    for (var i=0; i<outputArr.length; i++) {
	outputStr += outputArr[i] + '\n';
    }

    fs.writeFile(outputFile, outputStr, function(err) {
    	if(err) { return console.log(err); }
    });
};

prax.horizConn = function(rowArr, symbols) {
    var count = rowArr.length, strLen = 0, newStr, output = '';
    // Loop through each piece of the row
    // Skip the last one
    for (var i=0; i<(count-1); i++) {
	// If this is the first row, it should stay intact, but we need to add a mark
	// after it to connect the pieces
	if (i == 0) {
	    output = rowArr[i] + symbols.mark;
	} else {
	    strLen = rowArr[i].length;
	    // Build the new string using marks
	    for(newStr = ''; newStr.length < strLen; newStr += symbols.on){}
	    output += newStr + symbols.mark;
	}
    }

    return output + rowArr[count - 1];
};

prax.drawPaths = function(iArr, symbols) {
    var rowArr = [];
    // General sequence, go through each row looking for the first # from left to right
    for (var i=0; i<iArr.length; i++) {
	if (iArr[i].indexOf(symbols.mark) > -1) {
	    // Break the row apart based the mark
	    rowArr = iArr[i].split(symbols.mark);
	    // If there's a second mark, we need to connect the 2
	    // Checking for 3 as the array will be in more than 3 parts if there were
	    // 2 or more marks
	    if (rowArr.length > 3) {
		iArr[i] = prax.horizConn(rowArr, symbols);
	    } else {
		console.log('theres only one on this row!');
	    }
	    // for (var x=0; x<rowArr.length; x++) {
	    // 	// Here we need to start with the second 
	    // }
	}
    }
    console.dir(iArr);
};

prax.runPather = function (settings) {
    // Read the input file
    var input = settings.fs.readFileSync(settings.input).toString();
    // Get the total number of hash marks
    settings.totalMarks = (input.split(settings.symbols.mark).length -1);
    // Convert the input into an array 
    input = input.split("\n");

    // Make sure that there are at least 2 marks in the input file
    if (settings.totalMarks > 1) {
	var newSequece = prax.drawPaths(input, settings.symbols);
	
	// Write the output file contents
	prax.writeOutput(settings.fs, input, settings.output);
    } else {
	console.log('File not changed. Input does not contain enough ' + 
		    settings.symbols.mark + '\'s.');
    }
};

prax.init = function() {
    var settings = prax.getSettings();
    
    prax.runPather(settings);
};

prax.init();
